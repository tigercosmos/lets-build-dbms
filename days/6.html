
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>6: Client/Server Communication Implementation (2) Â· Let's build a DBMS: StellarSQL -- a minimal SQL DBMS written in Rust </title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="tigercosmos">
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-disqus/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-codeblock-filename/block.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="7.html" />
    
    
    <link rel="prev" href="5.html" />
    

    <style>
    @media only screen and (max-width: 640px) {
        .book-header .hidden-mobile {
            display: none;
        }
    }
    </style>
    <script>
        window["gitbook-plugin-github-buttons"] = {"buttons":[{"user":"tigercosmos","repo":"lets-build-dbms","type":"star","size":"small","count":true},{"user":"tigercosmos","type":"follow","width":"180","size":"small","count":true}]};
    </script>

    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-84804118-5"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'UA-84804118-5');</script>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Let's build a DBMS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="0.html">
            
                <a href="0.html">
            
                    
                    0: Introduction to the Series Articles
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="1.html">
            
                <a href="1.html">
            
                    
                    1: Preparation & Basic Infrastructure
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="2.html">
            
                <a href="2.html">
            
                    
                    2: Basic Concept of Server
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="3.html">
            
                <a href="3.html">
            
                    
                    3: Frontend/Backend Protocol
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="4.html">
            
                <a href="4.html">
            
                    
                    4: Client/Server Communication Implementation (1)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="5.html">
            
                <a href="5.html">
            
                    
                    5: Introduce to RDBMS and SQL
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.8" data-path="6.html">
            
                <a href="6.html">
            
                    
                    6: Client/Server Communication Implementation (2)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="7.html">
            
                <a href="7.html">
            
                    
                    7: SQL Parser
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="8.html">
            
                <a href="8.html">
            
                    
                    8: SQL Parser - Lexical Scanner
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="9.html">
            
                <a href="9.html">
            
                    
                    9: Lexical Scanner Implementation (1)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="10.html">
            
                <a href="10.html">
            
                    
                    10: Lexical Scanner Implementation (2)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="11.html">
            
                <a href="11.html">
            
                    
                    11: Lexical Scanner Implementation (3)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="12.html">
            
                <a href="12.html">
            
                    
                    12: Lexical Scanner Case Study
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="13.html">
            
                <a href="13.html">
            
                    
                    13: Recursive Descent Parser
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="14.html">
            
                <a href="14.html">
            
                    
                    14: Lexical Scanner Implementation (4)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="15.html">
            
                <a href="15.html">
            
                    
                    15: Lexical Scanner Implementation (5)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="16.html">
            
                <a href="16.html">
            
                    
                    16: Good RDB Design with the Concept of Normal Forms
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.19" data-path="17.html">
            
                <a href="17.html">
            
                    
                    17: Parser Implementation (1)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.20" data-path="18.html">
            
                <a href="18.html">
            
                    
                    18: Parser Implementation (2)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.21" data-path="19.html">
            
                <a href="19.html">
            
                    
                    19: Parser Implementation (3): Understand SQL grammar
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.22" data-path="20.html">
            
                <a href="20.html">
            
                    
                    20: Parser Implementation (4)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.23" data-path="21.html">
            
                <a href="21.html">
            
                    
                    21: First Implementation for Database Components
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.24" data-path="22.html">
            
                <a href="22.html">
            
                    
                    22: Update Components of Database
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.25" data-path="23.html">
            
                <a href="23.html">
            
                    
                    23: Implement Table insert_row
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.26" data-path="24.html">
            
                <a href="24.html">
            
                    
                    24: Different Client Design of DBMS
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >6: Client/Server Communication Implementation (2)</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="6-clientserver-communication-implementation2">6: Client/Server Communication Implementation(2)</h1>
<p>2018/10/21</p>
<p>I have told you that I want to implement client/server communication two days ago. Unfortunately, I spend lots of hour for understanding <code>Tokio.rs</code> and <code>future</code>. So this is the part 2 of this topic.</p>
<p><code>Tokio.rs</code> is a framework based on <code>future</code>, and <code>future</code> makes writing asynchronous program easy.</p>
<p>Asynchronous IO is always the most difficult part in an application, not to mention the fact that <code>Tokio.rs</code> is very new with few documents. Therefore, I need learn by programing, trying to make the code of <code>Tokio.rs</code> works.</p>
<p>Finally, I have done the communication between client and server. So let&apos;s look at what I have written in StellarSQL.</p>
<p>Each commits have their own meaning. I will explain the commits in order, and those commit also represent the process of my thoughts.</p>
<h2 id="communication">Communication</h2>
<p>Think about how server and client communicate with each other, we talked there is a protocol doing that. A protocol could be HTTP or defined by ourselves. Protocols are based on TCP or UDP, and we will use TCP for DBMS due to the trait that TCP won&apos;t lose packets.</p>
<p>Let&apos;s dig deeper for a communication.</p>
<p>A client creates a socket and send some bytes to a server. The bytes are encode in the format of a protocol, which clients and server should all follow with. The server receive sockets and get bytes, and the server will parse the bytes to meaningful messages according to the protocol.</p>
<p>Once the server get a message, which might be any commands, including searching, inserting, deleting, ect., the server will reply the result to client. In the same way, the server will give the answer in a response which is serialized by the protocol.</p>
<h2 id="commits">Commits</h2>
<p>If you read this series after today for a long time, I believe most parts would be changed a lot. Though I am going to write down some code in the following part, you can check out commits if you like to read what the whole code looks like at this moment.</p>
<p>These commits are done in today:</p>
<ul>
<li>main: implement connection</li>
<li>connection: mod add <code>request</code> and <code>response</code></li>
<li>response: enum Response and impl serialize</li>
<li>request: enum Request and impl parse</li>
<li>message: define struc and impl</li>
</ul>
<p>Or you can run the command to see the version in today:</p>
<pre><code class="lang-sh">git checkout 569fd175824000d372370496949d487a87823a25
</code></pre>
<h2 id="code">Code</h2>
<p>Recall that we listen sockets and want to do <code>process()</code></p>
<div><p class="code-filename">src/main.rs</p></div>
<pre><code class="lang-rust">    <span class="hljs-keyword">let</span> server = listener
        .incoming()
        .for_each(move |socket| {
            <span class="hljs-keyword">let</span> addr = socket.peer_addr().unwrap();
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;New Connection: {}&quot;</span>, addr);

            <span class="hljs-comment">// Spawn a task to process the connection</span>
            process(socket);

            <span class="hljs-literal">Ok</span>(())
        }).map_err(|err| {
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;accept error = {:?}&quot;</span>, err);
        });
</code></pre>
<p>The <code>process()</code> is doing the process of what I just talk about for communication above, and there are comments for explaining in the following snippet:</p>
<div><p class="code-filename">src/main.rs</p></div>
<pre><code class="lang-rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">process</span></span>(socket: TcpStream) {

    <span class="hljs-comment">// split socket into two parts</span>
    <span class="hljs-keyword">let</span> (reader, writer) = socket.split();

    <span class="hljs-comment">// make stream bytes to a message</span>
    <span class="hljs-keyword">let</span> messages = message::new(BufReader::new(reader));

    <span class="hljs-comment">// note the `move` keyword on the closure here which moves ownership</span>
    <span class="hljs-comment">// of the reference into the closure, which we&apos;ll need for spawning the</span>
    <span class="hljs-comment">// client below.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// The `map` function here means that we&apos;ll run some code for all</span>
    <span class="hljs-comment">// requests (lines) we receive from the client. The actual handling here</span>
    <span class="hljs-comment">// is pretty simple, first we parse the request and if it&apos;s valid we</span>
    <span class="hljs-comment">// generate a response.</span>
    <span class="hljs-keyword">let</span> responses =
        messages.map(move |message| <span class="hljs-keyword">match</span> Request::parse(&amp;message) {
            <span class="hljs-literal">Ok</span>(req) =&gt; req,
            <span class="hljs-literal">Err</span>(e) =&gt; <span class="hljs-keyword">return</span> Response::Error { msg: e },
        });

    <span class="hljs-comment">// At this point `responses` is a stream of `Response` types which we</span>
    <span class="hljs-comment">// now want to write back out to the client. To do that we use</span>
    <span class="hljs-comment">// `Stream::fold` to perform a loop here, serializing each response and</span>
    <span class="hljs-comment">// then writing it out to the client.</span>
    <span class="hljs-keyword">let</span> writes = responses.fold(writer, |writer, response| {
        <span class="hljs-keyword">let</span> response = response.serialize().into_bytes();
        write_all(writer, response).map(|(w, _)| w)
    });

    <span class="hljs-comment">// `spawn` this client to ensure it</span>
    <span class="hljs-comment">// runs concurrently with all other clients, for now ignoring any errors</span>
    <span class="hljs-comment">// that we see.</span>
    <span class="hljs-keyword">let</span> connection = writes.then(move |_| <span class="hljs-literal">Ok</span>(()));

    <span class="hljs-comment">// Spawn the task. Internally, this submits the task to a thread pool.</span>
    tokio::spawn(connection);
}
</code></pre>
<p>We see <code>message</code>, <code>response</code> and <code>request</code> in <code>main.rs</code>. These modules are defined in <code>connection</code> module.</p>
<p><code>message</code> is for parsing the stream into a <code>Message</code>, but I don&apos;t implement a well designed protocol. The <code>poll()</code> function will decode streams of each socket to messages, so we should implement our protocol here. Now it just see any &quot;lines&quot; sent from terminals entered by users as messages, so I delete <code>\n\r</code> in the function <code>poll()</code> (not showing here).</p>
<p>Note that <code>impl&lt;A&gt; Stream for Message&lt;A&gt;</code> is needed if we want to use functions of <code>future</code> crate and spawn the task to thread pool. (Remember <code>Tokio.rs</code> is based on <code>future</code>?)</p>
<div><p class="code-filename">src/connection/message.rs</p></div>
<pre><code class="lang-rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Message</span></span>&lt;A&gt; { <span class="hljs-comment">/* ... */</span>}

<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>&lt;A&gt;(a: A) -&gt; Message&lt;A&gt; { <span class="hljs-comment">/* ... */</span>}

<span class="hljs-keyword">impl</span>&lt;A&gt; Stream <span class="hljs-keyword">for</span> Message&lt;A&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">poll</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; Poll&lt;<span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">String</span>&gt;, io::Error&gt; {<span class="hljs-comment">/* ... */</span>}
}
</code></pre>
<p><code>request</code> and <code>response</code> define the types of requests and responses. Just like HTTP, you send request in <code>get</code>, <code>post</code>, or <code>put</code>, and get response with <code>code</code> 200, 300, 400. These modules are doing the same thing.</p>
<p>There should be many types in <code>Request</code>, but I don&apos;t do it yet. <code>request.parse()</code> will parse the request. In this step, it will check if the request is valid, such as authentication, and then return the response. The logic here might changed, because some logic could be better.</p>
<div><p class="code-filename">src/connection/request.rs</p></div>
<pre><code class="lang-rust"><span class="hljs-keyword">use</span> Response;

<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Request</span></span> {}

<span class="hljs-keyword">impl</span> Request {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">parse</span></span>(input: &amp;<span class="hljs-keyword">str</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;Response, <span class="hljs-built_in">String</span>&gt; {
        <span class="hljs-literal">Ok</span>(Response::OK {
            msg: input.to_string(),
        })
    }
}
</code></pre>
<p><code>Response</code> defines all response types, and it can <code>serialize()</code> the <code>Response</code> in order to send back to the client. There will be more types, and <code>serialize()</code> will follow the protocol.</p>
<div><p class="code-filename">src/connection/response.rs</p></div>
<pre><code class="lang-rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Response</span></span> {
    OK { msg: <span class="hljs-built_in">String</span> },
    Error { msg: <span class="hljs-built_in">String</span> },
}

<span class="hljs-keyword">impl</span> Response {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serialize</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">String</span> {
        <span class="hljs-keyword">match</span> *<span class="hljs-keyword">self</span> {
            Response::OK { <span class="hljs-keyword">ref</span> msg } =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;{}\n&quot;</span>, msg),
            Response::Error { <span class="hljs-keyword">ref</span> msg } =&gt; <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;Error: {}\n&quot;</span>, msg),
        }
    }
}
</code></pre>
<p>So, the communication works. Clients can connect to StellarSQL. Now StellarSQL just echoes the request to response. When I finish the database and SQL parts, it will be a real DBMS.</p>
<p>You can build and run with:</p>
<pre><code class="lang-sh">cargo run
</code></pre>
<p>then open another terminal run the command, and put any words:</p>
<pre><code class="lang-sh"><span class="hljs-comment"># A client connect to localhost 23333</span>
telnet localhost 23333
</code></pre>
<p>StellarSQL will echoes what you enter. :)</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="5.html" class="navigation navigation-prev " aria-label="Previous page: 5: Introduce to RDBMS and SQL">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="7.html" class="navigation navigation-next " aria-label="Next page: 7: SQL Parser">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"6: Client/Server Communication Implementation (2)","level":"1.8","depth":1,"next":{"title":"7: SQL Parser","level":"1.9","depth":1,"path":"days/7.md","ref":"days/7.md","articles":[]},"previous":{"title":"5: Introduce to RDBMS and SQL","level":"1.7","depth":1,"path":"days/5.md","ref":"days/5.md","articles":[]},"dir":"ltr"},"config":{"plugins":["expandable-chapters","github-buttons@3.0.0","github","disqus","codeblock-filename","custom-favicon"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"disqus":{"useIdentifier":false,"shortName":"lets-build-dbms"},"github":{"url":"https://github.com/tigercosmos/"},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"favicon":"./favicon.ico","codeblock-filename":{},"github-buttons":{"buttons":[{"user":"tigercosmos","repo":"lets-build-dbms","type":"star","size":"small","count":true},{"user":"tigercosmos","type":"follow","width":"180","size":"small","count":true}]},"custom-favicon":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"expandable-chapters":{}},"theme":"default","author":"tigercosmos","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Let's build a DBMS: StellarSQL -- a minimal SQL DBMS written in Rust ","gitbook":"*","description":""},"file":{"path":"days/6.md","mtime":"2018-11-08T15:59:48.640Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2018-11-08T16:00:47.858Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-github-buttons/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
        
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/URI.js/1.16.1/URI.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-disqus/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

